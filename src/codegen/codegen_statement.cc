#include "codegen/codegen.h"

#include <iostream>
#include "llvm/Transforms/Utils/BasicBlockUtils.h"

#include "ast/block_statement.h"
#include "ast/if_statement.h"
#include "ast/return_statement.h"
#include "ast/value.h"

namespace codegen {

using namespace llvm;  // NOLINT

void CodeGenerator::visit(ast::BlockStatement* node) {
  auto current_block =
      BasicBlock::Create(context_, current_function_name_, current_function_);
  ir_builder_.SetInsertPoint(current_block);

  current_block_ = current_block;
  for (auto const& statement : node->statements()) {
    statement->accept(*this);

    // TODO: plug the SSA code here for PHI nodes.

    if (return_unhandled_) {
      return;
    }
  }
}

void CodeGenerator::visit(ast::ReturnStatement* node) {
  if (node->value().is_ok()) {
    node->value().value_or_die()->accept(*this);
    assert(gen_value_ != nullptr && "No value generated by the visitor");
    ir_builder_.CreateRet(gen_value_);
  } else {
    ir_builder_.CreateRetVoid();
  }

  return_unhandled_ = true;
}

void CodeGenerator::visit(ast::IfStatement* node) {
  assert(current_block_ != nullptr);
  auto current_block = ir_builder_.GetInsertBlock();

  ast::IfStatement::ConditionList::const_iterator condition =
      std::begin(node->conditions());
  ast::IfStatement::BodyList::const_iterator body = std::begin(node->bodies());

  // We need to store all the blocks that doesn't return in all cases
  // so that we make them jump to the end of the 'if'.
  std::vector<BasicBlock*> blocks_with_continuation;

  // We generate the first block of code for the 'if' statement.
  (*condition++)->accept(*this);
  auto condition_value = gen_value_;
  (*body++)->accept(*this);
  CONSUME_UNHANDLED_RETURN(auto has_returned);
  if (!has_returned) {
    blocks_with_continuation.push_back(current_block_);
  }

  BasicBlock* last_block = current_block_;
  BasicBlock* jump_block = current_block;
  while (condition != std::end(node->conditions())) {
    BasicBlock* merge_block =
        BasicBlock::Create(context_, "if.elseif", current_function_);

    // We create the jump instuctions.
    ir_builder_.SetInsertPoint(jump_block);
    auto equality =
        ir_builder_.CreateICmpNE(condition_value, ir_builder_.getInt32(0));
    ir_builder_.CreateCondBr(equality, last_block, merge_block);

    // We create the new block of code for the 'else if' stmt.
    (*body++)->accept(*this);
    last_block = current_block_;

    CONSUME_UNHANDLED_RETURN(auto has_returned);
    if (!has_returned) {
      blocks_with_continuation.push_back(current_block_);
    }

    // We get the Value of the current condition for the next conditional jump.
    (*condition++)->accept(*this);
    condition_value = gen_value_;

    jump_block = merge_block;
  }

  if (node->else_statement().is_ok()) {
    // Create the 'else' block code.
    node->else_statement().value_or_die()->accept(*this);

    // Jump to it with condition.
    ir_builder_.SetInsertPoint(jump_block);
    auto equality =
        ir_builder_.CreateICmpNE(condition_value, ir_builder_.getInt32(0));
    ir_builder_.CreateCondBr(equality, last_block, current_block_);

    CONSUME_UNHANDLED_RETURN(auto has_returned);
    if (!has_returned) {
      blocks_with_continuation.push_back(current_block_);
    }

    last_block = current_block_;
  }

  // The continuation of the 'if'.
  BasicBlock* if_end_block =
      BasicBlock::Create(context_, "if.end", current_function_);

  // We jump to the continuation if some blocks
  // doesn't returns in all cases.
  for (auto const& block : blocks_with_continuation) {
    ir_builder_.SetInsertPoint(block);
    ir_builder_.CreateBr(if_end_block);
  }

  ir_builder_.SetInsertPoint(jump_block);
  // We check if we didn't finished on a 'else if' stmt or if
  // there is an end to the 'if'.
  if (!blocks_with_continuation.empty() || !node->else_statement().is_ok()) {
    if (!node->else_statement().is_ok()) {
      auto equality =
          ir_builder_.CreateICmpNE(condition_value, ir_builder_.getInt32(0));
      ir_builder_.CreateCondBr(equality, last_block, if_end_block);
    }

    ir_builder_.SetInsertPoint(if_end_block);
    current_block_ = if_end_block;
  } else {
    // All the 'if' cases returned, we delete the if.end block
    // and tells the class there is no need to continue from this block.
    DeleteDeadBlock(if_end_block);
    return_unhandled_ = true;
  }
}
}
