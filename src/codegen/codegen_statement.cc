#include "codegen/codegen.h"

#include <iostream>
#include "llvm/Transforms/Utils/BasicBlockUtils.h"

#include "ast/block_statement.h"
#include "ast/if_statement.h"
#include "ast/return_statement.h"
#include "ast/value.h"
#include "util/option.h"

namespace codegen {

using namespace llvm;  // NOLINT

void CodeGenerator::visit(ast::BlockStatement* node) {
  auto current_block =
      BasicBlock::Create(context_, current_function_name_, current_function_);
  ir_builder_.SetInsertPoint(current_block);

  current_block_ = current_block;
  for (auto const& statement : node->statements()) {
    statement->accept(*this);

    // TODO: plug the SSA code here for PHI nodes.

    if (return_unhandled_) {
      current_block_ = current_block;
      return;
    }
  }
}

void CodeGenerator::visit(ast::ReturnStatement* node) {
  if (node->value().is_ok()) {
    node->value().value_or_die()->accept(*this);
    assert(gen_value_ != nullptr && "No value generated by the visitor");
    ir_builder_.CreateRet(gen_value_);
  } else {
    ir_builder_.CreateRetVoid();
  }

  return_unhandled_ = true;
}

void CodeGenerator::visit(ast::IfStatement* node) {
  assert(current_block_ != nullptr);
  auto if_start_block = current_block_;

  Option<Value*> condition_value = none;
  if (node->condition().is_ok()) {
    node->condition().value_or_die()->accept(*this);
    condition_value = gen_value_;
  }

  // We generate the if block.
  node->body()->accept(*this);
  CONSUME_UNHANDLED_RETURN(auto if_body_returned);
  BasicBlock* if_block = current_block_;

  // We generate the else block if needed.
  bool else_body_returned = false;
  Option<BasicBlock*> else_block = none;
  Option<BasicBlock*> ifelse_block = none;

  if (node->else_statement().is_ok()) {
    current_block_ = BasicBlock::Create(context_, "if.else", current_function_);
    ifelse_block = current_block_;

    node->else_statement().value_or_die()->accept(*this);
    CONSUME_UNHANDLED_RETURN(else_body_returned);
    else_block = current_block_;
  }

  bool else_only_returned =
      !condition_value.is_ok() && if_body_returned && !else_block.is_ok();
  bool if_or_elseif_returned =
      if_body_returned && else_body_returned && else_block.is_ok();
  return_unhandled_ = if_or_elseif_returned || else_only_returned;

  if (!return_unhandled_) {
    current_block_ = BasicBlock::Create(context_, "if.end", current_function_);
  }

  ir_builder_.SetInsertPoint(if_start_block);
  if (condition_value.is_ok()) {
    auto equality = ir_builder_.CreateICmpNE(condition_value.value_or_die(),
                                             ir_builder_.getInt32(0));
    // Handle the if alone, or the if else.
    ir_builder_.CreateCondBr(equality, if_block,
                             ifelse_block.value_or(current_block_));
  } else {
    // Handle the else alone.
    ir_builder_.CreateBr(if_block);
  }

  if (return_unhandled_) return;

  if (!if_body_returned) {
    ir_builder_.SetInsertPoint(if_block);
    ir_builder_.CreateBr(current_block_);
  }

  if (!else_body_returned && else_block.is_ok()) {
    ir_builder_.SetInsertPoint(else_block.value_or_die());
    ir_builder_.CreateBr(current_block_);
  }

  if (current_block_ != nullptr) {
    ir_builder_.SetInsertPoint(current_block_);
  }
}
}  // namespace codegen
