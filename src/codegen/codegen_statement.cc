#include "codegen/codegen.h"

#include <iostream>
#include "llvm/Transforms/Utils/BasicBlockUtils.h"

#include "ast/block_statement.h"
#include "ast/if_statement.h"
#include "ast/return_statement.h"
#include "ast/value.h"
#include "util/logging.h"
#include "util/option.h"

namespace codegen {

using namespace llvm;  // NOLINT

void CodeGenerator::visit(ast::BlockStatement* node) {
  auto current_function = current_function_;
  for (auto const& statement : node->statements()) {
    CHECK(!has_returned_);
    statement->accept(*this);

    // Restore state of node.
    current_function_ = current_function;
    gen_value_ = none;
    // TODO: plug the SSA code here for PHI nodes.
  }
}

void CodeGenerator::visit(ast::ReturnStatement* node) {
  if (node->value().is_ok()) {
    node->value().value_or_die()->accept(*this);
    assert(gen_value_.is_ok() && "No value generated by the visitor");
    ir_builder_.CreateRet(gen_value_.value_or_die());
  } else {
    ir_builder_.CreateRetVoid();
  }

  has_returned_ = true;
}

void CodeGenerator::visit(ast::IfStatement* node) {
  auto if_start_block = ir_builder_.GetInsertBlock();

  node->condition()->accept(*this);
  CHECK(gen_value_.is_ok()) << "If condition with no value";
  Value* condition_value = gen_value_.value_or_die();
  // Create the initial comparison.
  auto equality =
      ir_builder_.CreateICmpNE(condition_value, ir_builder_.getInt32(0));

  // We generate the if block.
  CHECK(current_function_.is_ok())
      << "IfStatement can't live outside of function";
  BasicBlock* if_block =
      BasicBlock::Create(context_, "if.true", current_function_.value_or_die());
  ir_builder_.SetInsertPoint(if_block);
  node->body()->accept(*this);
  auto if_body_returned = consume_return_value();
  BasicBlock* end_if_block = ir_builder_.GetInsertBlock();

  bool else_body_returned = false;
  Option<BasicBlock*> else_block = none;
  Option<BasicBlock*> end_else_block = none;

  // We generate the else block if needed.
  if (node->else_statement().is_ok()) {
    CHECK(current_function_.is_ok())
        << "IfStatement can't live outside of function";
    else_block = BasicBlock::Create(context_, "if.else",
                                    current_function_.value_or_die());
    ir_builder_.SetInsertPoint(else_block.value_or_die());
    node->else_statement().value_or_die()->accept(*this);
    else_body_returned = consume_return_value();
    end_else_block = ir_builder_.GetInsertBlock();
  }

  // The if has returned only if both bodies have returned.
  has_returned_ = if_body_returned && else_body_returned;

  // We check if the statement returned in all cases. If it didn't, the we need
  // to create the 'if continuation' so that the execution continue after
  // passing
  // the if statement. For instance:
  // if (cond) return; // We need to continue as there is an implicit else case.
  // if (cond) return; else return; // We don't need to continue as we already
  // returned in all cases.
  // if (cond) return; else if (cond) return; // Same here, implicit else.
  Option<BasicBlock*> ifend_block = none;
  if (!has_returned_) {
    CHECK(current_function_.is_ok())
        << "IfStatement can't live outside of function";
    ifend_block = BasicBlock::Create(context_, "if.end",
                                     current_function_.value_or_die());
  }

  CHECK(else_block.is_ok() || ifend_block.is_ok())
      << "No else, but no end generated.";
  // We make the jump from the if start block to the bodies.
  // Handle the if alone, or the if else.
  ir_builder_.SetInsertPoint(if_start_block);
  ir_builder_.CreateCondBr(equality, if_block,
                           else_block.is_ok() ? else_block.value_or_die()
                                              : ifend_block.value_or_die());

  // We jump from the bodies to if.end if needed.
  if (!has_returned_) {
    assert(ifend_block.is_ok());
    const auto& ifend = ifend_block.value_or_die();
    if (!if_body_returned) {
      ir_builder_.SetInsertPoint(end_if_block);
      ir_builder_.CreateBr(ifend);
    }

    if (!else_body_returned && else_block.is_ok()) {
      assert(end_else_block.is_ok());
      ir_builder_.SetInsertPoint(end_else_block.value_or_die());
      ir_builder_.CreateBr(ifend);
    }

    ir_builder_.SetInsertPoint(ifend);
  }
}
}  // namespace codegen
