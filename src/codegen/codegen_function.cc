#include "llvm/IR/CallingConv.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"

#include "ast/function_declaration.h"
#include "ast/return_statement.h"
#include "ast/value.h"
#include "codegen/codegen.h"

namespace codegen {

using namespace llvm;  // NOLINT

void CodeGenerator::visit(ast::ReturnStatement* node) {
  if (node->value().is_ok()) {
    node->value().value_or_die()->accept(*this);
    assert(gen_value_ != nullptr && "No value generated by the visitor");
    ir_builder_.CreateRet(gen_value_);
  } else {
    ir_builder_.CreateRetVoid();
  }
}

void CodeGenerator::visit(ast::FunctionDeclaration* node) {
  std::vector<Type*> param_types;  // fill by visiting.
  ArrayRef<Type*> param_types_array(param_types);
  FunctionType* t = FunctionType::get(IntegerType::get(context_, 32),
                                      param_types_array, /*isVarArg=*/false);
  Constant* c = module_->getOrInsertFunction(node->id().short_name(), t);

  Function* llvm_function = cast<Function>(c);
  llvm_function->setCallingConv(CallingConv::C);
  BasicBlock* block = BasicBlock::Create(context_, "entry", llvm_function);
  ir_builder_.SetInsertPoint(block);
  assert(node->body().is<ast::FunctionDeclaration::StatementsBody>() &&
         "FunctionDeclaration body was not transformed, still a value");
  node->accept_body(*this);
}

}  // namespace codegen
